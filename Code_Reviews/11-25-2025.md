I will be starting a code review soon

the goal for today is to understand auth_routes.py in a deeper sense with code review.

the original code:

from fastapi import APIRouter, HTTPException
from sqlmodel import Session, select
from backend.app.core.database import engine, User, get_session
from backend.app.model.auth_models import UserCreate, UserLogin, Token
from backend.app.core.auth_utils import hash_password, verify_password, create_access_token
from passlib.context import CryptContext

router = APIRouter()

@router.get("/users")
def list_users():
    return {"message" : "List of users coming soon"}

# this is my register user route
@router.post("/register")
# I decided to add a username condition to check f it is none then ignore, but if it is filled it should check if there is an existing username already
def register_user(user : UserCreate):
    with Session(engine) as session:
        # check if email exists
        existing_user = session.exec(
            select(User).where(User.email == user.email)
        ).first()
        if existing_user:
            raise HTTPException(status_code = 400, detail = "Email Already exists")
        if user.username:
            existing_username = session.exec(
                select(User).where(User.username == user.username)
            ).first()
            
            if existing_username:
                raise HTTPException(status_code=400, detail="Username Exists")
        # create a new user with hash password
        new_user = User(
            email = user.email,
            username = user.username,
            hashed_password = hash_password(user.password)
        )
        
        session.add(new_user)
        session.commit()
        session.refresh(new_user)
        
        return {"message" : "User Succesfully Created", "user_id" : new_user.id}

# this is my login route
@router.post("/login", response_model = Token)
def login(user: UserLogin):
    with Session(engine) as session:
        db_user = session.exec(select(User).where(User.email == user.email)).first()
        if not db_user or not verify_password(user.password, db_user.hashed_password):
            raise HTTPException(status_code = 401, detail = "Invalid Credentials")
        
        token = create_access_token({"sub" : str(db_user.id),
                                     "email" : db_user.email,
                                     "username" : db_user.username
                                     })
        return Token(access_token = token, token_type = "bearer")

start:

from fastapi import APIRouter, HTTPException
from sqlmodel import Session, select
from backend.app.core.database import engine, User, get_session
from backend.app.model.auth_models import UserCreate, UserLogin, Token
from backend.app.core.auth_utils import hash_password, verify_password, create_access_token
from passlib.context import CryptContext

these are the imports from my local packages (codes i made), thirdparty libraries, and built-in libraries and packages

router = APIRouter()

instantiate or assigning a variable named router as the APIRouter(router is an instance of FastAPI's APIRouter class), It groups related endpoints into a modular router

@router.get("/users")
def list_users():
    return {"message" : "List of users coming soon"}

an api route that uses the HTTP method get and assigning it to /users, it has a method called list_users() it doesn't really serve any purpose other than for me to test whether the server of the backend is up and running

@router.post("/register")
def register_user(user : UserCreate):
    with Session(engine) as session:
        # check if email exists
        existing_user = session.exec(
            select(User).where(User.email == user.email)
        ).first()
        if existing_user:
            raise HTTPException(status_code = 400, detail = "Email Already exists")
        if user.username:
            existing_username = session.exec(
                select(User).where(User.username == user.username)
            ).first()
            
            if existing_username:
                raise HTTPException(status_code=400, detail="Username Exists")
        # create a new user with hash password
        new_user = User(
            email = user.email,
            username = user.username,
            hashed_password = hash_password(user.password)
        )
        
        session.add(new_user)
        session.commit()
        session.refresh(new_user)
        
        return {"message" : "User Succesfully Created", "user_id" : new_user.id}

an api route that uses the HTTP method for posting an object at /register for registering a user into the server's database.
this api creates a method called register_user that uses user, and UserCreate, it also uses Session with engine as its session.
created a variable existing_user to check whether the User's email is already existing by checking in the database for similarity using both the User input and the table user in the database with the method first()
aside from email it also checks if the username(an optional input when creating a new user), is not a duplicate too using the first() method. after verifying the integrigity of both the email and username it proceeds to creating the new user with creating a variable that inherits its parameters to the parent class User in the database.

@router.post("/login", response_model = Token)
def login(user: UserLogin):
    with Session(engine) as session:
        db_user = session.exec(select(User).where(User.email == user.email)).first()
        if not db_user or not verify_password(user.password, db_user.hashed_password):
            raise HTTPException(status_code = 401, detail = "Invalid Credentials")
        
        token = create_access_token({"sub" : str(db_user.id),
                                     "email" : db_user.email,
                                     "username" : db_user.username
                                     })
        return Token(access_token = token, token_type = "bearer")
this is my block of code for the /login api, it first defines the parameter that it will use, response_model = Token, the token is given by the JWT Token bearer.
it proceeds to a function called login which has parameters user, and UserLogin, in this api it also uses engine as its Session and named it session.
db_user verifies whether the inserted credentials are inside the backend's database or not, if it is then it will proceed to create an access token using create_access_token and it provides sub for user's id, email for user's email, and username for user's username, then it proceeds to return the Token. but if the user is not in the backend's database it displays an error using HTTPException.

missed information:

using Session(engine) manually couples the routes to the database implementation. Best practice is to use Depends(get_session) so that sessions are centrally managed, testable, and automatically cleaned up

existing_user = session.exec(select(User).where(User.email == user.email)).first()
if existing_user: ...

Instead of doing two separate queries (email, usernaem) we could combine it with an OR Filter (I need to learn more about different optimization specially OR Filter)

hashing before storing: 
Hashing ensures plaintext passwords are never stored in the database, if the database is compramised, attackers stil cannot retrieve real passwords.

@router.post("/login", response_model=Token)

The token model's role:
FastAPI will automatically validate, serialize, and document the response using the Token ydantic/SQLModel