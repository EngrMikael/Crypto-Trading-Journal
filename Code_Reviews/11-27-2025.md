a code review of my main.py

code:

from fastapi import FastAPI, HTTPException
from sqlmodel import Session, select
from contextlib import asynccontextmanager
from fastapi.middleware.cors import CORSMiddleware

from backend.app.core.database import create_db_and_tables, engine, User
from backend.app.api import auth_routes, journal_routes
from backend.app.core.middleware import LogMiddleware

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Creating Database Tables...")
    create_db_and_tables()
    print("Database tables created!")
    yield
    print("Server Shutting down...")

app = FastAPI(lifespan=lifespan)

# Middleware
app.add_middleware(LogMiddleware)  # logs all requests
origins = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

# API routes
app.include_router(auth_routes.router, prefix="/api")
app.include_router(journal_routes.router, prefix="/api")

@app.get("/")
async def root():
    try:
        with Session(engine) as session:
            session.exec(select(User)).first()
        return {"message": "Hello World", "status": "database OK"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database ERROR: {str(e)}")        

@app.get("/health")
async def health():
    return {"status": "healthy"}


code review:

from fastapi import FastAPI, HTTPException
from sqlmodel import Session, select
from contextlib import asynccontextmanager
from fastapi.middleware.cors import CORSMiddleware

from backend.app.core.database import create_db_and_tables, engine, User
from backend.app.api import auth_routes, journal_routes
from backend.app.core.middleware import LogMiddleware

these are my imports for fastapi packages, sqlmodel, contextlib, middleware, and my personal packages from my root directory

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Creating Database Tables...")
    create_db_and_tables()
    print("Database tables created!")
    yield
    print("Server Shutting down...")

i called a function from contextlib called asynccontextmanager to manage the lifespan method, lifespan is what defines what happens when the server starts,ongoing, and ends/shutdown. it uses the paramaeter app assigned as FastAPI

app = FastAPI(lifespan=lifespan)

I created a variable named app that inherits the function FastAPI and it uses parameters lifespan assigned to my lifespan method

# Middleware
app.add_middleware(LogMiddleware)  # logs all requests
origins = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

I added a middleware to handle the incvoming requests. using FastAPI's middleware I can only accept the requests from the origins I assigned and log them. I also allowed origins, credentioals, and accept all methods and headers from the origins only.

# API routes
app.include_router(auth_routes.router, prefix="/api")
app.include_router(journal_routes.router, prefix="/api")

using include_router, a method from APIRouter I set a prefix of /api for both the apis from auth_routes and journal_routes

@app.get("/")
async def root():
    try:
        with Session(engine) as session:
            session.exec(select(User)).first()
        return {"message": "Hello World", "status": "database OK"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database ERROR: {str(e)}")        

a simple api call for checking if the server is functioning properly using the HTTP GET method. it returns the message if it is working properly, and raise an error when it is not using HTTPException

@app.get("/health")
async def health():
    return {"status": "healthy"}

another simple api call for checking the health of the server.

Code review: core/database.py

full code:
# backend/app/core/database.py
from sqlmodel import SQLModel, Field, create_engine, Session, select
from contextlib import contextmanager
from datetime import date
import os
from dotenv import load_dotenv

# BASE_DIR is the root folder, wherein the .env file is located
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
dotenv_path = os.path.join(BASE_DIR, ".env")

print(f"Looking for .env at: {dotenv_path}")
print(f".env exists: {os.path.exists(dotenv_path)}")

load_dotenv(dotenv_path)

# PostgreSQL connection string from .env
DATABASE_URL = os.getenv("DATABASE_URL")
print(f"DATABASE_URL loaded: {DATABASE_URL}")

engine = create_engine(DATABASE_URL, echo = True)

# my two schemas
class User(SQLModel, table = True):
    # I'm adding an option to add a username whene creating a new user, it is optional when creating the account but can be updated in the user settings/dashboard.
    __tablename__ = "users"  # type: ignore
    __table_args__ = {"schema": "auth"}
    id: int | None = Field(default = None, primary_key = True)
    email: str = Field(unique = True, index = True)
    username: str | None = None
    hashed_password: str

class Journal(SQLModel, table = True):
    __tablename__ = "journal_info" #type: ignore
    __table_args__ = {"schema": "journal"}
    id: int | None = Field(default = None, primary_key = True)
    # to establish connection/relation i must call on the User Table from auth schema
    user_id : int = Field(foreign_key = "auth.users.id")
    asset_coin : str
    value_entered : float
    value_outcome : float
    date_open : date
    date_closed : date | None = None
    note : str | None = None
    strategy : str | None = None
    p_l : bool | None = None
    
def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

@contextmanager
def get_session():
    with Session(engine) as session:
        yield session

# dependency for FastAPI routes
def get_session_dependency():
    with Session(engine) as session:
        yield session


explanation: 
from sqlmodel import SQLModel, Field, create_engine, Session, select
from contextlib import contextmanager
from datetime import date
import os
from dotenv import load_dotenv

these are my imports from sqlmodel (SQLModel, Field, create_engine, Session, select), contextlib (contextmanager), datetime (date), os, and dotenv(load_dotenv)

