a code review of my main.py

code:

from fastapi import FastAPI, HTTPException
from sqlmodel import Session, select
from contextlib import asynccontextmanager
from fastapi.middleware.cors import CORSMiddleware

from backend.app.core.database import create_db_and_tables, engine, User
from backend.app.api import auth_routes, journal_routes
from backend.app.core.middleware import LogMiddleware

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Creating Database Tables...")
    create_db_and_tables()
    print("Database tables created!")
    yield
    print("Server Shutting down...")

app = FastAPI(lifespan=lifespan)

# Middleware
app.add_middleware(LogMiddleware)  # logs all requests
origins = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

# API routes
app.include_router(auth_routes.router, prefix="/api")
app.include_router(journal_routes.router, prefix="/api")

@app.get("/")
async def root():
    try:
        with Session(engine) as session:
            session.exec(select(User)).first()
        return {"message": "Hello World", "status": "database OK"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database ERROR: {str(e)}")        

@app.get("/health")
async def health():
    return {"status": "healthy"}


code review:

from fastapi import FastAPI, HTTPException
from sqlmodel import Session, select
from contextlib import asynccontextmanager
from fastapi.middleware.cors import CORSMiddleware

from backend.app.core.database import create_db_and_tables, engine, User
from backend.app.api import auth_routes, journal_routes
from backend.app.core.middleware import LogMiddleware

these are my imports for fastapi packages, sqlmodel, contextlib, middleware, and my personal packages from my root directory

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Creating Database Tables...")
    create_db_and_tables()
    print("Database tables created!")
    yield
    print("Server Shutting down...")

i called a function from contextlib called asynccontextmanager to manage the lifespan method, lifespan is what defines what happens when the server starts,ongoing, and ends/shutdown. it uses the paramaeter app assigned as FastAPI

app = FastAPI(lifespan=lifespan)

I created a variable named app that inherits the function FastAPI and it uses parameters lifespan assigned to my lifespan method

# Middleware
app.add_middleware(LogMiddleware)  # logs all requests
origins = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

I added a middleware to handle the incvoming requests. using FastAPI's middleware I can only accept the requests from the origins I assigned and log them. I also allowed origins, credentioals, and accept all methods and headers from the origins only.

# API routes
app.include_router(auth_routes.router, prefix="/api")
app.include_router(journal_routes.router, prefix="/api")

using include_router, a method from APIRouter I set a prefix of /api for both the apis from auth_routes and journal_routes

@app.get("/")
async def root():
    try:
        with Session(engine) as session:
            session.exec(select(User)).first()
        return {"message": "Hello World", "status": "database OK"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database ERROR: {str(e)}")        

a simple api call for checking if the server is functioning properly using the HTTP GET method. it returns the message if it is working properly, and raise an error when it is not using HTTPException

@app.get("/health")
async def health():
    return {"status": "healthy"}

another simple api call for checking the health of the server.

Code review: core/database.py

full code:
# backend/app/core/database.py
from sqlmodel import SQLModel, Field, create_engine, Session, select
from contextlib import contextmanager
from datetime import date
import os
from dotenv import load_dotenv

# BASE_DIR is the root folder, wherein the .env file is located
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
dotenv_path = os.path.join(BASE_DIR, ".env")

print(f"Looking for .env at: {dotenv_path}")
print(f".env exists: {os.path.exists(dotenv_path)}")

load_dotenv(dotenv_path)

# PostgreSQL connection string from .env
DATABASE_URL = os.getenv("DATABASE_URL")
print(f"DATABASE_URL loaded: {DATABASE_URL}")

engine = create_engine(DATABASE_URL, echo = True)

# my two schemas
class User(SQLModel, table = True):
    # I'm adding an option to add a username whene creating a new user, it is optional when creating the account but can be updated in the user settings/dashboard.
    __tablename__ = "users"  # type: ignore
    __table_args__ = {"schema": "auth"}
    id: int | None = Field(default = None, primary_key = True)
    email: str = Field(unique = True, index = True)
    username: str | None = None
    hashed_password: str

class Journal(SQLModel, table = True):
    __tablename__ = "journal_info" #type: ignore
    __table_args__ = {"schema": "journal"}
    id: int | None = Field(default = None, primary_key = True)
    # to establish connection/relation i must call on the User Table from auth schema
    user_id : int = Field(foreign_key = "auth.users.id")
    asset_coin : str
    value_entered : float
    value_outcome : float
    date_open : date
    date_closed : date | None = None
    note : str | None = None
    strategy : str | None = None
    p_l : bool | None = None
    
def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

@contextmanager
def get_session():
    with Session(engine) as session:
        yield session

# dependency for FastAPI routes
def get_session_dependency():
    with Session(engine) as session:
        yield session


explanation: 
from sqlmodel import SQLModel, Field, create_engine, Session, select
from contextlib import contextmanager
from datetime import date
import os
from dotenv import load_dotenv

these are my imports from sqlmodel (SQLModel, Field, create_engine, Session, select), contextlib (contextmanager), datetime (date), os, and dotenv(load_dotenv)

BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
dotenv_path = os.path.join(BASE_DIR, ".env")

print(f"Looking for .env at: {dotenv_path}")
print(f".env exists: {os.path.exists(dotenv_path)}")

load_dotenv(dotenv_path)

this code block is for locating and loading my .env file for backend. first it locates the .env for backend and assign it to a variable (BASE_DIR), then create another variable (dotenv_path) and assign the value for its location from BASE_DIR and the name of the file in strings (".env"). print the status while it is looking for the .env file and if whether the .env file exists and display the location. after locating the .env we load it using the function load_dotenv and use the dotenv_env as its parameter/variable

# PostgreSQL connection string from .env
DATABASE_URL = os.getenv("DATABASE_URL")
print(f"DATABASE_URL loaded: {DATABASE_URL}") 
<!-- we can remove {DATABASE_URL} for security reasons, but for now we let it stay -->

engine = create_engine(DATABASE_URL, echo = True)

this code block is for the connectiong of my Database to my backend/FastAPI. first retrieving the data from the .env file and assigning it to DATABASE_URL. after we get the url of our database we can now create an an engine using the function create_engine from sqlmodel using the DATABASE_URL as its credentials and set the echo to True.

class User(SQLModel, table = True):
    # I'm adding an option to add a username whene creating a new user, it is optional when creating the account but can be updated in the user settings/dashboard.
    __tablename__ = "users"  # type: ignore
    __table_args__ = {"schema": "auth"}
    id: int | None = Field(default = None, primary_key = True)
    email: str = Field(unique = True, index = True)
    username: str | None = None
    hashed_password: str

now that the connection from our database and the FastAPI/Backend is stablished we can now create a class called User and assign it to the schema "auth" and tablename "users" from the database. create a variable to insert in the database (id, email, username, and hashed_password): id is assigned as an int and a primary_key therefore it is using the function Field(), email is assigned as a string and is using Field for checking the uniqueness and its repetetiveness, username as a string or none it is None because when registering a user it is optional to set a username, hashed_password is converting the password into hashed version using the algorithm and encryption (SECRET_KEY).

class Journal(SQLModel, table = True):
    __tablename__ = "journal_info" #type: ignore
    __table_args__ = {"schema": "journal"}
    id: int | None = Field(default = None, primary_key = True)
    # to establish connection/relation i must call on the User Table from auth schema
    user_id : int = Field(foreign_key = "auth.users.id")
    asset_coin : str
    value_entered : float
    value_outcome : float
    date_open : date
    date_closed : date | None = None
    note : str | None = None
    strategy : str | None = None
    p_l : bool | None = None

creating another class that is assigned for the schema "journal" and the table "journal_info", creating variables for the table (id, user_id, asset_coin, value_entered, value_outcome, date_open, date_closed, note, strategy, and p_l). now since i want the info of trades to be private and only be accessible by the user we create a foreign key, we import the id from the schema "auth" and assign it to user_id since this is a foreign key we need to use the function Field() and the built-it parameter foreign_key and assign "auth.users.id" to it auth is the schema, users is  the table, and id is the variable inside that table.
and the trade's id is the primary key therefore uses a funtion Field to it. asset_coin is a tring, value_entered and value_outcome are float, date_open and date_closed are date but the latter can be accepted as an optional (empty) which signifies it is an open trade. note, and strategy are both strings and are optional, p_l is a boolean value but can be empty if it is an open trade.

