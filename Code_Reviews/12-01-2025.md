/core/middleware.py 

full code:

from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
from starlette.requests import Request
from starlette.responses import Response

class LogMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        print(f"Request: {request.method} {request.url}")
        response = await call_next(request)
        print(f"Response status: {response.status_code}")
        return response

code review:

from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
from starlette.requests import Request
from starlette.responses import Response

these are the imports that will be used in middleware, all came from starlette and 3 different sub-packages.

class LogMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        print(f"Request: {request.method} {request.url}")
        response = await call_next(request)
        print(f"Response status: {response.status_code}")
        return response

created a class for a logging middleware that inherits from Starlette's base called BaseHTTPMiddleware, it uses a async instead of the normal def for the sole reason of efficiency. we can view async as a multitasker of some sort, while waiting for the action it takes on another request, unlike the good-old def it waits for the process to finish before proceeding to the next request. dispatch uses self, request: Request, and call_next. I also created a variable that waits for the next request using await call_next(request), now we can print the status of the response using response.status_code, then we return response

so basically, middleware class inherits from Starlette's  BaseHTTPMiddleware, which it defines the structure for handling requests and responses inside FastAPI.

dispatch is defined as asyinc because FastAPI/Starlette is built around asynchronous I/O (input output). when we use asynf it makes it non-blocking, which means that while the middleware is waiting for I/O, the event loop switch to handling other incoming requests allowing the server to scale much more efficiently under load. if I used a normal def dispatch, it would block the entire worker until the response is fully processed, reducing concurrency.

the parameters, self refers to the current instance of the middleware class. request : Request if the incoming HTTP request object containing method, headers, URL, body, etc., call_next is a function that forwards the request to the next middleware or th actual endpoint, since this is async we must await it.

finally, this middleware logs incoming requests and its corresponding response status.


/api/journal_routes.py

full code:

from fastapi import APIRouter, Depends
from sqlmodel import Session, select
from backend.app.core.database import get_session, Journal, get_session_dependency
from backend.app.model.journal_models import CreateTrade
from backend.app.core.auth_utils import get_current_user

router = APIRouter()

@router.get("/journal")
def list_of_trades(current_user: int = Depends(get_current_user), session: Session = Depends(get_session_dependency)):
    trades = session.exec(select(Journal).where(Journal.user_id == current_user)).all()
    return trades
  
@router.post("/register/trade")
def register_trade(
    journal_info: CreateTrade,
    current_user : int = Depends(get_current_user),
    session: Session = Depends(get_session_dependency)
    ):
        new_trade = Journal(
            user_id = current_user,
            asset_coin = journal_info.asset_coin,
            value_entered = journal_info.value_entered,
            value_outcome = journal_info.value_outcome,
            date_open = journal_info.date_open,
            date_closed = journal_info.date_closed,
            note = journal_info.note,
            strategy = journal_info.strategy,
            p_l = journal_info.p_l
        )
        
        session.add(new_trade)
        session.commit()
        session.refresh(new_trade)
        
        return {"message" : "New Trade Created succesfully", "trade id" : new_trade.id} 

code review:

this are the routes that are all related to journal. we can get the api routes for the journal itself, and registering a trade. 

from fastapi import APIRouter, Depends
from sqlmodel import Session, select
from backend.app.core.database import get_session, Journal, get_session_dependency
from backend.app.model.journal_models import CreateTrade
from backend.app.core.auth_utils import get_current_user

first off, we import the libraries needed to build the api routes.

router = APIRouter()

we instantiate a variable called router as APIRouter().

@router.get("/journal")
def list_of_trades(current_user: int = Depends(get_current_user), session: Session = Depends(get_session_dependency)):
    trades = session.exec(select(Journal).where(Journal.user_id == current_user)).all()
    return trades

we call router to do HTTP request using @ and the HTTP request. now in order to get the list of trades we create a method and name it list_of_trades, it hets the current_user and it is an int, in order to get the id we need to retrieve it from our auth_utils using get_current_user. we create a Session and name it session that Depends from get_session_dependency from our database.py. now we also use simple query using sqlmodel, as you noticed we used Session which is a sub-package of sqlmodel too aside from select, it is crucial to only retrieve the trades that are created by the user therefore we need use where as well and specify a condition. now we can return the trades.

@router.post("/register/trade")
def register_trade(
    journal_info: CreateTrade,
    current_user : int = Depends(get_current_user),
    session: Session = Depends(get_session_dependency)
    ):
        new_trade = Journal(
            user_id = current_user,
            asset_coin = journal_info.asset_coin,
            value_entered = journal_info.value_entered,
            value_outcome = journal_info.value_outcome,
            date_open = journal_info.date_open,
            date_closed = journal_info.date_closed,
            note = journal_info.note,
            strategy = journal_info.strategy,
            p_l = journal_info.p_l
        )
        
        session.add(new_trade)
        session.commit()
        session.refresh(new_trade)
        
        return {"message" : "New Trade Created succesfully", "trade id" : new_trade.id} 

we call router to do another HTTP request using @ and the HTTP request. this api is for creating or registering a new trade. we specified the parameters that we wil use, and inside the refgister_trade funcion we created a method named new_trade, where it would get the user's input values and register it to Journal class with necessary uinput fields. after taking the input from user using serssion we update the database using add(new_trade) and comitting the update to the database, finally we refresh the session using (new_trade). we return a message that the ctrade is created, and display the trade id