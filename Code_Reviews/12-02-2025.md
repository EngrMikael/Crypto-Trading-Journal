Deeper Code Review of backend logic and files:

In the imports SQLModel, Field, and Sessions are the core pieces of SQLModel ORM. contextmanager are for the session provider. load_dotenv is used for loading the .env file for the backend. SQLModel is a hybrid mix of Pydantic and SQLAlchemy.

when loading the .env __file__ defines the current file, when locating the .env file for backend goes up for 4 levels from the project root, hence the long line of os.path.dirname. if the files will be moved in the future it would cause an error so the best practice for this would be BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../../"))
dotenv_path = os.path.join(BASE_DIR, ".env") instead of BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
dotenv_path = os.path.join(BASE_DIR, ".env")

print(f"Looking for .env at: {dotenv_path}")
print(f".env exists: {os.path.exists(dotenv_path)}")
print(f"DATABASE_URL loaded: {DATABASE_URL}")

those files are great for debugging or for project building, but once in the production phase it must be removed, since it will leak confidential data that are used within the backend.

engine = create_engine(DATABASE_URL, echo=True)

echo=True prints raw SQL queries, which is good for learning, echo should only be used in development phase

when creating the User Model specifying the __tablename__ and __table_args__ is a good practice since SQLModel will create the schema if it doesn't already exists

when it comes to handling passwords or user keys it must always be stored as hash, and never plain text.

class Journal(SQLModel, table = True):
    __table_args__ = {"schema": "journal"}
user_id : int = Field(foreign_key = "auth.users.id")

the setup of that code block is great, but the problem later would be SQLModel will generate contraints based on it, in order to solve that problem we can ad a relationship later 
user: User = Relationship(back_populates="journal_entries")
