Deeper Code Review of backend logic and files:

In the imports SQLModel, Field, and Sessions are the core pieces of SQLModel ORM. contextmanager are for the session provider. load_dotenv is used for loading the .env file for the backend. SQLModel is a hybrid mix of Pydantic and SQLAlchemy.

when loading the .env __file__ defines the current file, when locating the .env file for backend goes up for 4 levels from the project root, hence the long line of os.path.dirname. if the files will be moved in the future it would cause an error so the best practice for this would be BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../../"))
dotenv_path = os.path.join(BASE_DIR, ".env") instead of BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
dotenv_path = os.path.join(BASE_DIR, ".env")

print(f"Looking for .env at: {dotenv_path}")
print(f".env exists: {os.path.exists(dotenv_path)}")
print(f"DATABASE_URL loaded: {DATABASE_URL}")

those files are great for debugging or for project building, but once in the production phase it must be removed, since it will leak confidential data that are used within the backend.

engine = create_engine(DATABASE_URL, echo=True)

echo=True prints raw SQL queries, which is good for learning, echo should only be used in development phase

when creating the User Model specifying the __tablename__ and __table_args__ is a good practice since SQLModel will create the schema if it doesn't already exists

when it comes to handling passwords or user keys it must always be stored as hash, and never plain text.

class Journal(SQLModel, table = True):
    __table_args__ = {"schema": "journal"}
user_id : int = Field(foreign_key = "auth.users.id")

the setup of that code block is great, but the problem later would be SQLModel will generate contraints based on it, in order to solve that problem we can ad a relationship later 
user: User = Relationship(back_populates="journal_entries")

def create_db_and_tables():
    SQLModel.metadata.create_all(engine)

the code snippet does not create schemas, and only creates tables, so before starting it must be created in PostgreSQL first. 

@contextmanager
def get_session():
    with Session(engine) as session:
        yield session

with this code block context-managed session factory is created and it ensures session opens, DB operations happen, session closes automatically rollback on error, cleanup always guaranteed. howeverm, t is not compatible with FastAPI's dependency inhection design

def get_session_dependency():
    with Session(engine) as session:
        yield session

since get_session(): is incorrect, i created a get_sesion_dependency, since FastAPI requires generator functions for dependncies.

the mistake is that I forgot to remove get_session() and have both it and get_sessio_dependency()

auth_utils.py

in the imports:
using passlib for hashing password is the industry's standard.
jose for JWT is common in Python APIs. OAuth2PasswordBearer integrates perfectly with FastAPI dependencies. displaying sensitive information inside the .env is dangerous, must be removed for production.

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/login")

To get a token, clients must POST to /api/login with email and password. the value automatically apears in the Swagger UI, tokenUrl must watch the actual login route.

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

since bcrypt is secure it is a wiser choice, auto ensures forward compatibility. and this snippet follow exact security best practices: 
def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(password: str, hashed_password: str) -> bool:
    return pwd_context.verify(password, hashed_password)


def create_access_token(data: dict, expires_delta: int | None = None) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes = expires_delta or ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm = ALGORITHM)

when creating a JWT it must always have an expiration, it must also copy and update the payload, and also uses correct JWT format.

when designing the dependency for get_current_user() it must have the exact token, decode it properly, and validate it, then return the user ID. there are missing steps, it is only returning the user_id, most apps return User model instance.

suggestions and ratings of auth_utils.py
What you got very right:
    Your password hashing is textbook perfect.
    JWT creation is correct.
    OAuth2 bearer is correctly used as a dependency.
    Security errors follow proper HTTP standards.
    Code is readable and simple.

What is needed to improve
High priority
    Centralize config (SECRET_KEY, DB URL)
    Remove duplicated .env loading
    Validate SECRET_KEY & DATABASE_URL
    Update tokenUrl to match real route path
Medium priority
    Add "iat" to JWT payload
    Simplify .env path logic
    Remove debug prints in production
Optional (advanced)
    Make get_current_user return full User object instead of just id.

auth_routes.py

clean imports, excellent usage of sqlmodel. but CryptContext is imported but was not used, so it is safe to remove it (migh remove it later).

once again get_session() was imported but was not used, and manually did with Session(engine) as session. for best practices, it is better use FastAPI dependencies like in get_session_dependency() from earlier. the setup of router = APIRouter() is simple and correct.

for the api when registering a user: using UserCreate Pydantic model ensures validation, and it is good practice when checking for the email uniqueness to prevent email duplication. adding an optional username when creating a user is well thought.

while creating the user the email checking is using a correct query, the .first() is used correctly, the error code 400 is also correct.

while creating the user since the username is an optional field it used a somewhat similar logic to the email checking logic, but what makes it different is since it is an optional field it still validates it nonetheless and username is only checked if provided.

note from gpt: instead of checking email and username separately, consider applying unique constraints in the SQLModel User class. that way your DB enforces uniqueness, and your API only handles validation (I will look into it later, and try to apply this logic)

new_user = User(...) is for creating the new user and it is correct, it is hashing HTML users' password correctly via utility function.

